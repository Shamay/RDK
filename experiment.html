<!DOCTYPE html>
<html>
  <head>
    <!--

		RDK plugin for JsPsych
		----------------------

		This code was created in the Consciousness and Metacognition Lab at UCLA,
		under the supervision of Brian Odegaard and Hakwan Lau

		----------------------

		Copyright (C) 2017  Sivananda Rajananda

		This program is free software: you can redistribute it and/or modify
		it under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version.

		This program is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.

		You should have received a copy of the GNU General Public License
		along with this program.  If not, see <http://www.gnu.org/licenses/>.

		-->

    <title>Dot Motion Task</title>
      <script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
      <script src="jspsych-6.0.1/jspsych.js"></script>
      <script src="jspsych-6.0.1/jspsych-6.0.1/plugins/jspsych-html-keyboard-response.js"></script>
      <script src="jspsych-6.0.1/jspsych-6.0.1/plugins/jspsych-instructions.js"></script>
      <script src="jspsych-6.0.1/jspsych-6.0.1/plugins/jspsych-dotmotion.js"></script>
      <script src="jspsych-6.0.1/jspsych-6.0.1/plugins/jspsych-fullscreen.js"></script>
      <link href="jspsych-6.0.1/css/jspsych.css" rel="stylesheet" type="text/css"></link>
  </head>
  <body></body>
  <script>

    //The main timeline to be fed into jsPsych.init
    var timeline = [];

    // Loading config and trial data file synchronously
    var config, headers, lines;

    $.ajax({
      url: 'config.json',
      async: false,
      dataType: 'json',
      success: function (response) {
        config = response[0]
      }
    });

    $.ajax({
        url: "data.csv",
        async: false,
        dataType: "text",
        success: function (response) {
          processData(response);
        }
     });

    function processData(allText) {
        var allTextLines = allText.split(/\r\n|\n/);
        headers = allTextLines[0].split(',');
        lines = [];

        for (var i=1; i<allTextLines.length; i++) {
            var data = allTextLines[i].split(',');
            if (data.length == headers.length) {
                var tarr = [];
                for (var j=0; j<headers.length; j++) {
                    tarr.push(data[j]);
                }
                lines.push(tarr);
            }
        }
    }

    // fullscreen mode
    timeline.push({
      type: 'fullscreen',
      fullscreen_mode: true,
      message: '<p>The experiment will switch to full screen mode when you press the button below</p>',
      button_label: 'Start Experiment'
    });

    /* define instructions block */
    var instructions = {
      type: 'instructions',
      pages: [
          'Welcome to the experiment. Click next to begin.',
          //'This is the second page of instructions.',
          //'This is the final page.'
      ],
      show_clickable_nav: true,
      post_trial_gap: 1000
    };
    timeline.push(instructions);

    //---------Create trials---------

    var cue = {
      type: "dotmotion",
      stage: "cue", // cue or task
      choices: jsPsych.NO_KEYS, //Choices available to be keyed in by participant

      task: jsPsych.timelineVariable('task'),
      cue_shape: jsPsych.timelineVariable('cue_shape'),

      trial_duration: config.cue_duration, //Duration of each cue in ms
    }

    var fixation = {
      type: 'html-keyboard-response',
      stimulus: function(){
        if(config.fixation_cross){ // Whether or not to include fixation cross)
          return '<div style="font-size:60px;">+</div>';
        }else{
          return '';
        }
      }(),

      choices: jsPsych.NO_KEYS,
      trial_duration: config.inter_trial_interval,

      on_start: function(fixation){
        // get data from previous trial
        var data = jsPsych.data.get().last(1).values()[0];

        // prompt whether the previous trial was correct or not
        if(typeof data.correct === "undefined"){
          fixation.prompt = '';
        }else if(data.correct){
          fixation.prompt = '<div class = centerbox><div style="color:green;font-size:60px"; class = center-text>Correct!</div></div>';
        }else{
          fixation.prompt = '<div class = centerbox><div style="color:red;font-size:60px"; class = center-text>Incorrect</div></div>';
        }

        // dynamically change inter_trial_interval
        if(data.response_ends_trial && data.fill_ITT && data.rt != -1){
  				fixation.trial_duration += Math.floor(data.trial_duration - data.rt);
  			}
      }
    }

    var stimulus = {
      type: "dotmotion",
      stage: "task", // cue or task
      RDK_type: 3, //The type of RDK used
      choices: ['a', 'l'], //Choices available to be keyed in by participant

      task: jsPsych.timelineVariable('task'),
      correct_choice: jsPsych.timelineVariable('correct_response'),
      coherent_direction: jsPsych.timelineVariable('coherent_direction'),
      coherent_color: jsPsych.timelineVariable('coherent_color'),
      cue_shape: jsPsych.timelineVariable('cue_shape'),
      motionCoherence:  jsPsych.timelineVariable('motionCoherence'),
      colorCoherence: jsPsych.timelineVariable('colorCoherence'),

      number_of_dots: config.number_of_dots, //Total number of dots in the aperture
      trial_duration: config.trial_duration, //Duration of each trial in ms

      response_ends_trial: config.response_ends_trial, //Whether response ends the trial or not
			fill_ITT: config.fill_ITT, // Whether to standardize trial length or not, condition on response_ends_trial being true

      responseAfterTimeout: config.responseAfterTimeout,
      dot_timeout: config.dot_timeout
    }

    //generate timeline variables
    function generateTrial(vars){
      var cue_shape;
      if(vars[5] == 'c'){ //circle (color)
        cue_shape = 1;
      }else if(vars[5] == 't'){ //triangle (color)
        cue_shape = 3;
      }else if(vars[5] == 'd'){ //diamond (motion)
        cue_shape = 4;
      }else if(vars[5] == 'r'){ //rectangle (motion)
        cue_shape = 2;
      }

      var correct_response;
      if(vars[4] == 'motion' && vars[6] == 'up'){
        correct_response = 'l';
      }else if(vars[4] == 'motion' && vars[6] == 'down'){
        correct_response = 'a';
      }else if(vars[4] == 'color' && vars[8] == 'red'){
        correct_response = 'a';
      }else if(vars[4] == 'color' && vars[8] == 'blue'){
        correct_response = 'l';
      }

      //convert vertical/horizontal to degree notation
      var degrees;
      if (config.coherentAxis ==  'verticalAxis'){
        degrees = 270;
      }else if (config.coherentAxis ==  "horizontalAxis") {
        degrees = 180;
      }

      var coherent_direction;
      if(vars[6] == 'up'){
        coherent_direction = degrees - 180;
      }else if(vars[6] == 'down'){
        coherent_direction = degrees;
      }

      var coherent_color;
      if(vars[8] == 'red'){
        coherent_color = 'red';
      }else if(vars[8] == 'blue'){
        coherent_color = 'blue';
      }

      return [{
          //id: vars[0],
          //block: vars[1],
          //mblock: vars[2],
          //trial: vars[3],
          task: vars[4],
          cue_shape: cue_shape,
          correct_response: correct_response,
          coherent_direction: coherent_direction,
          motionCoherence: vars[7],
          coherent_color: coherent_color,
          colorCoherence: vars[9]
        }];
    }

    // generate sequence
    for (line in lines){
      var trial_vars = generateTrial(lines[line]); //generate timeline variables

      if(lines[line][3] == 1){
        var cue_sequence = {
          timeline: [cue, fixation, stimulus, fixation],
          timeline_variables: trial_vars
          }
        timeline.push(cue_sequence);
      }else{
        var stim_sequence = {
          timeline: [stimulus, fixation],
          timeline_variables: trial_vars
          }
        timeline.push(stim_sequence);
      }
    }
		//---------Run the experiment---------

		//Initiate the experiment
		jsPsych.init({
			timeline: timeline,
      //show_progress_bar: true,
			on_finish: function(){ //Execute this when the experiment finishes
				//jsPsych.data.localSave('testSave.csv', 'csv'); //Save the data locally in a .csv file
				jsPsych.data.displayData(); //Display the data onto the browser screen

        //jsPsych.data.getInteractionData(); LOOK INTO THIS

        // select task trials
        var task_trials = jsPsych.data.get().filter({stage: 'task'});
        var rt_data = task_trials.select('rt').values;
        var acc_data = task_trials.select('correct').values;

        outputData(rt_data,acc_data);
			}
		})

    function outputData(rt,acc){
      headers.push('rt');
      headers.push('correct');
      for(line in lines){
        lines[line].push(rt[line]);
        lines[line].push(acc[line]);
      }

      let csv;
      for(let col = 0; col < headers.length; col++){
        csv += headers[col] + ",";
      }
      csv += '\r\n';

      // Loop the array of objects
      for(let row = 0; row < lines.length; row++){
        for(let col = 0; col < headers.length; col++){
          csv += lines[row][col] + ",";
        }
        csv += '\r\n';
      }

      // Once we are done looping, download the .csv by creating a link
      let link = document.createElement('a')
      link.id = 'download-csv'
      link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(csv));
      link.setAttribute('download', 'output.csv');
      document.body.appendChild(link)
      document.querySelector('#download-csv').click()
    }

  </script>
  </html>
